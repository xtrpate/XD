# This file was generated by the Tkinter Designer by Parth Jadhav
# https://github.com/ParthJadhav/Tkinter-Designer


from pathlib import Path
import sys
import subprocess
import mysql.connector
import tkinter as tk
# Explicit imports to satisfy Flake8
from tkinter import Tk, Canvas, Entry, Text, Button, PhotoImage, messagebox, ttk, Listbox

admin_name = "Admin" # Default if not passed
if len(sys.argv) > 1:
    admin_name = sys.argv[1] # Get admin name from command-line argument
else:
    print("Warning: Admin name not provided to notification script.")


# --- Global Variables ---
all_users = [] # To store fetched users for autocomplete
selected_user_id = None # To store the ID if a single user is selected

# --- Database Connection & User Fetching ---
def get_db_connection():
    try:
        return mysql.connector.connect(
            host="localhost",
            user="root",
            password="",
            database="copy_corner_db"
        )
    except mysql.connector.Error as err:
        messagebox.showerror("Database Error", f"Connection failed: {err}")
        return None

def fetch_users_for_autocomplete():
    """Fetches user_id and username from the users table for autocomplete."""
    global all_users
    conn = get_db_connection()
    if not conn: return []

    try:
        cursor = conn.cursor(dictionary=True)
        # Fetching id and username
        query = "SELECT user_id, username FROM users ORDER BY username ASC"
        cursor.execute(query)
        all_users = cursor.fetchall()
        cursor.close()
        conn.close()
        return all_users
    except mysql.connector.Error as err:
        messagebox.showerror("Database Error", f"Error fetching users: {err}")
        return []

# --- UI Interaction Functions ---

def toggle_user_entry():
    """Enables/disables the user entry and clears/hides suggestions based on radio button."""
    global selected_user_id
    if send_to_var.get() == "single":
        user_entry.config(state=tk.NORMAL)
        user_entry.delete(0, tk.END) # Clear previous entry
        selected_user_id = None # Reset selected user
    else:
        user_entry.config(state=tk.DISABLED)
        user_entry.delete(0, tk.END)
        hide_suggestions()
        selected_user_id = None # Reset selected user

def update_user_suggestions(event=None):
    """Filters users based on entry and updates the listbox."""
    global selected_user_id
    search_term = user_entry.get().lower()
    user_listbox.delete(0, tk.END) # Clear previous suggestions
    selected_user_id = None # Reset if user is typing again

    if not search_term:
        hide_suggestions()
        return

    matches = [user for user in all_users if search_term in user['username'].lower()]

    if matches:
        for user in matches:
            # Store both username and id, display username
            user_listbox.insert(tk.END, f"{user['username']} (ID: {user['user_id']})")
        # Position listbox below entry
        entry_x = user_entry.winfo_x()
        entry_y = user_entry.winfo_y()
        entry_height = user_entry.winfo_height()
        user_listbox.place(x=entry_x, y=entry_y + entry_height, width=user_entry.winfo_width())
        user_listbox.lift() # Bring listbox to the front
    else:
        hide_suggestions()

def select_user_from_list(event=None):
    """Puts the selected username in the entry and stores the ID."""
    global selected_user_id
    selection_indices = user_listbox.curselection()
    if not selection_indices:
        return

    selected_text = user_listbox.get(selection_indices[0])
    # Extract username and ID
    username = selected_text.split(" (ID: ")[0]
    user_id_str = selected_text.split(" (ID: ")[1].replace(")", "")
    selected_user_id = int(user_id_str)

    user_entry.delete(0, tk.END)
    user_entry.insert(0, username)
    hide_suggestions()

def hide_suggestions(event=None):
    """Hides the suggestion listbox."""
    # Add a small delay so click event on listbox can register first
    window.after(150, user_listbox.place_forget)

# --- Send Notification Logic ---

def send_notification():
    """Validates input and sends the notification (placeholder)."""
    send_to = send_to_var.get()
    user_text = user_entry.get().strip()
    subject = subject_entry.get("1.0", tk.END).strip() # Use Text get method
    message = message_text.get("1.0", tk.END).strip()

    # --- Validation ---
    if not send_to:
        messagebox.showerror("Input Error", "Please select 'Single User' or 'All User'.")
        return

    if send_to == "single":
        if not user_text:
            messagebox.showerror("Input Error", "Please enter or select a username.")
            return
        # More robust check: ensure the entered text corresponds to a selected ID
        if selected_user_id is None:
             # Check if the current text matches exactly one user (case-insensitive)
             matches = [user for user in all_users if user['username'].lower() == user_text.lower()]
             if len(matches) == 1:
                 select_user_id = matches[0]['user_id'] # Use the matched ID
                 print(f"Assuming user: {matches[0]['username']} (ID: {select_user_id})")
             else:
                messagebox.showerror("Input Error", "Please select a valid user from the suggestions or ensure the username is exact.")
                return
        else:
             select_user_id = selected_user_id # Use the ID stored during listbox selection

    if not subject:
        messagebox.showerror("Input Error", "Please enter a subject.")
        return

    if not message:
        messagebox.showerror("Input Error", "Please enter a message.")
        return

    # --- Sending Logic (Placeholder) ---
    try:
        conn = get_db_connection()
        if not conn: return
        cursor = conn.cursor()

        if send_to == "single":
            # Insert notification for a single user
            sql = """
                            INSERT INTO notifications (user_id, subject, message)
                            VALUES (%s, %s, %s)
                        """
            cursor.execute(sql, (select_user_id, subject, message))
            conn.commit()
            messagebox.showinfo("Success", f"Notification sent to user ID {select_user_id}!")

        elif send_to == "all":
             # Fetch all user IDs first
             cursor.execute("SELECT user_id FROM users")
             user_ids = [row[0] for row in cursor.fetchall()]

             if not user_ids:
                 messagebox.showwarning("No Users", "There are no users to send notifications to.")
                 return

             # Prepare data for bulk insert
             sql = """
                             INSERT INTO notifications (user_id, subject, message)
                             VALUES (%s, %s, %s)
                         """
             data_to_insert = [(user_id, subject, message) for user_id in user_ids]
             cursor.executemany(sql, data_to_insert)
             conn.commit()
             messagebox.showinfo("Success", f"Notification sent to all {len(user_ids)} users!")

        cursor.close()
        conn.close()

        # Clear fields after sending
        send_to_var.set(None) # Reset radio
        user_entry.delete(0, tk.END)
        subject_entry.delete("1.0", tk.END)
        message_text.delete("1.0", tk.END)
        toggle_user_entry() # Disable user entry if needed


    except mysql.connector.Error as err:
        messagebox.showerror("Database Error", f"Failed to send notification: {err}")
    except Exception as e:
         messagebox.showerror("Error", f"An unexpected error occurred: {e}")


# --- Rounded Rectangle Function ---
def round_rectangle(canvas, x1, y1, x2, y2, r=15, **kwargs):
    points = [
        x1 + r, y1, x2 - r, y1, x2, y1, x2, y1 + r,
        x2, y2 - r, x2, y2, x2 - r, y2, x1 + r, y2,
        x1, y2, x1, y2 - r, x1, y1 + r, x1, y1
    ]
    return canvas.create_polygon(points, smooth=True, **kwargs)


# --- Sidebar Buttons with Navigation ---
def open_admin_dashboard():
    window.destroy()
    subprocess.Popen([sys.executable, "admin_dashboard.py", admin_name])

# def go_back_to_dashboard():
#     """Opens the admin dashboard, passing the admin name back."""
#     window.destroy()
#     # Pass the current admin_name back to the dashboard script
#     subprocess.Popen([sys.executable, "admin_dashboard.py", admin_name])


def open_admin_print():
    window.destroy()
    subprocess.Popen([sys.executable, "admin_print.py", admin_name])

def open_admin_report():
    window.destroy()
    subprocess.Popen([sys.executable, "admin_report.py", admin_name])

def open_admin_user():
    window.destroy()
    subprocess.Popen([sys.executable, "admin_user.py", admin_name])

# --- Logout Function ---
def logout():
    messagebox.showinfo("Logged Out", "Logout successful!")
    subprocess.Popen([sys.executable, "login.py"])
    window.destroy()

def create_rounded_menu_button(canvas, x, y, w, h, text, command=None):
    rect = round_rectangle(canvas, x, y, x + w, y + h, r=10, fill="#FFFFFF", outline="#000000", width=1)
    txt = canvas.create_text(x + 25, y + 8, text=text, anchor="nw", fill="#000000", font=("Inter Bold", 15))

    def on_click(event):
        if command:
            command()

    def on_hover(event):
        canvas.itemconfig(rect, fill="#E8E8E8")
        window.config(cursor="hand2")

    def on_leave(event):
        canvas.itemconfig(rect, fill="#FFFFFF")
        window.config(cursor="")

    for tag in (rect, txt):
        canvas.tag_bind(tag, "<Button-1>", on_click)
        canvas.tag_bind(tag, "<Enter>", on_hover)
        canvas.tag_bind(tag, "<Leave>", on_leave)

# --- GUI Setup ---
OUTPUT_PATH = Path(__file__).parent
ASSETS_PATH = OUTPUT_PATH / Path(r"D:\downloadss\New folder\Tkinter\Tkinter-Designer-master\build\assets\frame5") # Check asset path


def relative_to_assets(path: str) -> Path:
    # Basic error handling for assets path
    asset_file = ASSETS_PATH / Path(path)
    if not asset_file.is_file():
        print(f"Warning: Asset not found at {asset_file}")
    return asset_file




window = Tk()
window_width = 905
window_height = 567

screen_width = window.winfo_screenwidth()
screen_height = window.winfo_screenheight()
x = int((screen_width / 2) - (window_width / 2))
y = int((screen_height / 2) - (window_height / 2))
window.geometry(f"{window_width}x{window_height}+{x}+{y}")
window.configure(bg="#FFFFFF")
window.title("Admin Notification")


canvas = Canvas(
    window,
    bg = "#FFFFFF",
    height = 567,
    width = 907,
    bd = 0,
    highlightthickness = 0,
    relief = "ridge"
)

canvas.place(x = 0, y = 0)
canvas.create_rectangle(
    19.0,
    15.0,
    890.0,
    555.0,
    fill="#FFF6F6",
    outline="#000000")

canvas.create_rectangle(
    40.0,
    33.0,
    869.0,
    537.0,
    fill="#FFFFFF",
    outline="#000000")

canvas.create_rectangle(
    50.0,
    41.0,
    253.0,
    530.0,
    fill="#FFFFFF",
    outline="#000000")

# --- Load Logo ---
try:
    image_image_1 = PhotoImage(file=relative_to_assets("image_1.png"))
    image_1 = canvas.create_image(151.0, 79.0, image=image_image_1)
except tk.TclError:
    print("Warning: Could not load logo image_1.png")
    image_image_1 = None # Prevent errors if image load fails

canvas.create_text(
    125.0,
    130.0,
    anchor="nw",
    text="ADMIN",
    fill="#000000",
    font=("Inter Bold", 15 * -1)
)

# --- Main Content Area ---
canvas.create_text(
    281.0,
    48.0,
    anchor="nw",
    text="Notifications",
    fill="#000000",
    font=("Inter Bold", 45 * -1)
)

canvas.create_rectangle(
    260.0,
    32.0,
    261.0,
    537.0,
    fill="#000000",
    outline="")

canvas.create_rectangle( # Main content background (optional, widgets cover it)
    281.0,
    100.0,
    849.0,
    517.0,
    fill="#FFFFFF",
    outline="#000000")


# --- Send To Options ---
canvas.create_text(314.0, 119.0, anchor="nw", text="Send to", fill="#000000", font=("Inter Bold", 14 * -1))
send_to_var = tk.StringVar(value=None) # Initialize variable, no default selection
print(f"Initial send_to_var value: {send_to_var.get()}")

single_user_rb = ttk.Radiobutton(
    window,
    text="Single User",
    variable=send_to_var,
    value="single",
    command=toggle_user_entry,
    style="TRadiobutton"
)
single_user_rb.place(x=375.0, y=117.0)


all_user_rb = ttk.Radiobutton(
    window,
    text="All User",
    variable=send_to_var,
    value="all",
    command=toggle_user_entry,
    style="TRadiobutton"
)
all_user_rb.place(x=489.0, y=117.0)


# --- User Entry and Autocomplete ---
canvas.create_text(334.0, 161.0, anchor="nw", text="User:", fill="#000000", font=("Inter Bold", 20 * -1))
user_entry = Entry(
    window,
    bd=0,
    bg="white",
    highlightthickness=1,
    highlightcolor="#000000",
    highlightbackground="#000000",
    font=("Inter", 12),
    state=tk.DISABLED # Start disabled
)
user_entry.place(
    x=395.0,
    y=159.0,
    width=248.0,
    height=26.0)

user_listbox = Listbox(
    window,
    bd=1,
    relief="solid",
    font=("Inter", 10),
    height=4 # Limit height
)
# Listbox is placed dynamically by update_user_suggestions

# Bindings for autocomplete
user_entry.bind("<KeyRelease>", update_user_suggestions)
user_listbox.bind("<ButtonRelease-1>", select_user_from_list) # Use ButtonRelease for reliability
user_entry.bind("<FocusOut>", hide_suggestions) # Hide when focus leaves entry


# --- Subject Entry ---
canvas.create_text(307.0, 200.0, anchor="nw", text="Subject:", fill="#000000", font=("Inter Bold", 20 * -1))
# Use Text widget for potentially longer subjects, but limit height
subject_entry = Text(
    window,
    bd=0,
    bg="white",
    highlightthickness=1,
    highlightcolor="#000000",
    highlightbackground="#000000",
    font=("Inter", 12),
    height=1 # Limit to roughly single line height initially
)
subject_entry.place(
    x=395.0,
    y=198.0,
    width=248.0,
    height=26.0)

# --- Message Text Area ---
canvas.create_text(429.0, 231.0, anchor="nw", text="Message", fill="#000000", font=("Inter Bold", 23 * -1))
message_text = Text(
    window,
    bd=0,
    bg="white",
    highlightthickness=1,
    highlightcolor="#000000",
    highlightbackground="#000000",
    font=("Inter", 12),
    wrap=tk.WORD # Wrap text nicely
)
message_text.place(
    x=297.0,
    y=260.0,
    width=363.0,
    height=204.0)


# --- Buttons ---

# Recreate Back button (using canvas drawing for style consistency)
back_btn_rect = round_rectangle(canvas, 301, 473, 301+59, 473+35, r=5, fill="#FFFFFF", outline="#000000", width=1, tags="back_btn")
back_btn_text = canvas.create_text(301+59/2, 473+35/2, text="Back", fill="#000000", font=("Inter Bold", 16), anchor="center", tags="back_btn")

# Recreate Send button
send_btn_rect = round_rectangle(canvas, 370, 473, 370+59, 473+35, r=5, fill="#000000", outline="#000000", width=1, tags="send_btn")
send_btn_text = canvas.create_text(370+59/2, 473+35/2, text="Send", fill="#FFFFFF", font=("Inter Bold", 16), anchor="center", tags="send_btn")

# Bind button actions
# canvas.tag_bind("back_btn", "<Button-1>", lambda e: print("Back clicked")) # Add actual back navigation if needed
canvas.tag_bind("send_btn", "<Button-1>", lambda e: send_notification())

# Button Hover Effects
for tag in ("back_btn", "send_btn"):
    canvas.tag_bind(tag, "<Enter>", lambda e: window.config(cursor="hand2"))
    canvas.tag_bind(tag, "<Leave>", lambda e: window.config(cursor=""))



# --- Activity Feed (Placeholder) ---
canvas.create_rectangle(
    671.0,
    110.0,
    837.0,
    505.0,
    fill="#FFFFFF",
    outline="#000000")

canvas.create_text(
    696.0,
    119.0,
    anchor="nw",
    text="Activity Feed",
    fill="#000000",
    font=("Inter Bold", 18 * -1)
)

# Placeholder feed items
feed_y = 148.0
feed_height = 30.0
for i in range(3):
    canvas.create_rectangle(
        676.0, feed_y + (i * (feed_height + 7)),
        831.0, feed_y + feed_height + (i * (feed_height + 7)),
        fill="#FFFFFF", outline="#000000")
    canvas.create_text(
        750.0, feed_y + 6 + (i * (feed_height + 7)),
        anchor="nw", text="-", fill="#000000", font=("Inter Bold", 15 * -1))


# --- Sidebar Buttons ---
create_rounded_menu_button(canvas, 73, 162, 151, 38, "Dashboard", open_admin_dashboard)
create_rounded_menu_button(canvas, 73, 218, 151, 38, "User", open_admin_user)
create_rounded_menu_button(canvas, 73, 275, 151, 38, "Print Jobs", open_admin_print)
create_rounded_menu_button(canvas, 73, 332, 151, 38, "Reports", open_admin_report)
create_rounded_menu_button(canvas, 73, 389, 151, 38, "Settings")
create_rounded_menu_button(canvas, 89, 462, 111, 38, "Logout", logout)

# --- Initial Setup ---
fetch_users_for_autocomplete() # Fetch users when the app starts
toggle_user_entry() # Set initial state of user entry based on default radio

window.resizable(False, False)
window.mainloop()